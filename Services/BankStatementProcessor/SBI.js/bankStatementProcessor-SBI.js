/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  };
  const transactions = [];
  let headerRowIndex = -1;
  let headerKeys = {};

  // Helper function to format date
  function formatDate(dateString) {
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) {
        return null; // Invalid date
      }
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    } catch (error) {
      return null; // Invalid date
    }
  }

  // Helper function to check if a row contains header values
  function isHeaderRow(row) {
    const headerValues = ["Date", "Narration or Details", "Withdrawal Amt. or Debit", "Deposit Amt. or Credit", "Closing Balance or Balance", "Details","Debit","Credit","Balance"];
    for (const key in row) {
      if (row.hasOwnProperty(key) && row[key]) {
        const value = String(row[key]).trim();
        if (headerValues.includes(value)) {
          return true;
        }
      }
    }
    return false;
  }
  
  function extractBankDetails(rawData) {
      for (const row of rawData) {
          for (const key in row) {
              if (row.hasOwnProperty(key) && row[key]) {
                  const value = String(row[key]).trim();
                  if (value.toLowerCase().includes("state bank of india") || value.toLowerCase().includes("sbi")) {
                      bank_details.bank_name = "State Bank of India";
                  }
                   if (value.toLowerCase().includes("account name")) {
                      let detailValue = rawData.find((r, index) => index > rawData.indexOf(row) && r[key] != null)
                      if(detailValue){
                           bank_details.account_holder_name = detailValue[Object.keys(detailValue)[0]]
                      }
                      
                  }
                 if (value.toLowerCase().includes("address") && bank_details.account_holder_name) {
                      bank_details.address = value.replace("Address","") || null;
                  }
                  
                  if (value.toLowerCase().includes("account number")) {
                        let accNoValue = rawData.find((r, index) => index > rawData.indexOf(row) && r[key] != null)
                      if(accNoValue){
                           bank_details.account_no = accNoValue[Object.keys(accNoValue)[0]]
                      }
                  }
                  const ifscKeywords = ["ifs code", "ifsc code", "ifsc", "ifs"];
                      if (ifscKeywords.some(keyword => value.toLowerCase().includes(keyword))) {
                          let ifscValue = rawData.find((r, index) => index > rawData.indexOf(row) && r[key] != null)
                          if(ifscValue){
                               bank_details.ifsc = ifscValue[Object.keys(ifscValue)[0]];
                          }
                      }
              }
          }
      }
  }
  
  extractBankDetails(rawData);

  // Find the header row and identify header keys
  for (let i = 0; i < rawData.length; i++) {
    if (isHeaderRow(rawData[i])) {
      headerRowIndex = i;
      for (const key in rawData[i]) {
        if (rawData[i].hasOwnProperty(key) && rawData[i][key]) {
          const value = String(rawData[i][key]).trim();
          if (value === "Date") {
            headerKeys.date = key;
          } else if (value === "Narration or Details" || value === "Details") {
            headerKeys.narration = key;
          } else if (value === "Withdrawal Amt. or Debit" || value === "Debit") {
            headerKeys.withdrawal = key;
          } else if (value === "Deposit Amt. or Credit" || value === "Credit") {
            headerKeys.deposit = key;
          } else if (value === "Closing Balance or Balance" || value === "Balance") {
            headerKeys.balance = key;
          }
        }
      }
      break;
    }
  }

  // Process transactions
  if (headerRowIndex !== -1) {
    let voucher_number = 1;
    for (let i = headerRowIndex + 1; i < rawData.length; i++) {
      const row = rawData[i];
      let date = null;
      if(headerKeys.date && row[headerKeys.date]){
          date = formatDate(row[headerKeys.date]);
      }
      
      const desc = headerKeys.narration && row[headerKeys.narration] ? String(row[headerKeys.narration]).trim() : null;
      let type = null;
      let amount = 0;

      if (headerKeys.withdrawal && row[headerKeys.withdrawal] && row[headerKeys.withdrawal] !== '-') {
        type = "withdrawal";
        amount = Number(row[headerKeys.withdrawal]);
        if (isNaN(amount)) {
          amount = 0;
        }
      } else if (headerKeys.deposit && row[headerKeys.deposit] && row[headerKeys.deposit] !== '-') {
        type = "deposit";
        amount = Number(row[headerKeys.deposit]);
        if (isNaN(amount)) {
          amount = 0;
        }
      }

      const balance = headerKeys.balance && row[headerKeys.balance] ? Number(row[headerKeys.balance]) : null;
      if (isNaN(balance)) {
        balance = null;
      }

      const transaction = {
        date,
        voucher_number: voucher_number++,
        amount,
        desc,
        from: null,
        to: null,
        type,
        balance,
      };

      transactions.push(transaction);
    }
  }

  return {
    bank_details,
    transactions,
  };
}

module.exports = processBankStatement;
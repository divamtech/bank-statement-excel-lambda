/**
 * Generated by Gemini AI - Attempt 2
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }
  const transactions = []
  let headerRowIndex = -1
  let keyMap = {}
  let voucher_number = 1

  // Helper function to try parsing various date formats
  function parseDate(dateString) {
    if (!dateString) return null

    const formats = [
      /^\d{2}\/\d{2}\/\d{4}$/, // DD/MM/YYYY
      /^\d{2}-\w{3}-\d{4}$/, // DD-Mon-YYYY
      /^\d{2}\/\d{2}\/\d{2}$/, // DD/MM/YY
      /^\d{4}-\d{2}-\d{2}$/, // YYYY-MM-DD
    ]

    const parsers = [
      (str) => {
        // DD/MM/YYYY
        const [day, month, year] = str.split('/').map(Number)
        return new Date(year, month - 1, day)
      },
      (str) => {
        // DD-Mon-YYYY
        const [day, monthStr, year] = str.split('-')
        const month = new Date(Date.parse(monthStr + ' 1, 2000')).getMonth()
        return new Date(year, month, day)
      },
      (str) => {
        // DD/MM/YY  (handle 2-digit year)
        const [day, month, year] = str.split('/').map(Number)
        const fullYear = year < 70 ? 2000 + year : 1900 + year
        return new Date(fullYear, month - 1, day)
      },
      (str) => {
        // YYYY-MM-DD
        const [year, month, day] = str.split('-').map(Number)
        return new Date(year, month - 1, day)
      },
    ]

    for (let i = 0; i < formats.length; i++) {
      if (formats[i].test(dateString)) {
        try {
          const date = parsers[i](dateString)
          if (!isNaN(date)) {
            const year = date.getFullYear()
            const month = String(date.getMonth() + 1).padStart(2, '0')
            const day = String(date.getDate()).padStart(2, '0')
            return `${year}-${month}-${day}`
          }
        } catch (e) {
          // Ignore parsing errors, try next format
        }
      }
    }

    // Try Excel date serial number (very basic)
    const excelSerial = parseInt(dateString, 10)
    if (!isNaN(excelSerial) && excelSerial > 0) {
      try {
        const excelEpoch = new Date(Date.UTC(1899, 11, 31))
        const date = new Date(excelEpoch.getTime() + excelSerial * 24 * 60 * 60 * 1000)
        const year = date.getFullYear()
        const month = String(date.getMonth() + 1).padStart(2, '0')
        const day = String(date.getDate()).padStart(2, '0')
        return `${year}-${month}-${day}`
      } catch (e) {
        //Ignore Excel Serial Date Parsing
      }
    }

    return null // No valid format found
  }

  function extractFromDescription(description) {
    if (!description) return { from: null, to: null }

    const upiPattern = /[a-zA-Z0-9.\-_]{2,}@[a-zA-Z0-9.\-_]{2,}/ // Basic UPI ID pattern
    const match = description.match(upiPattern)
    if (match) {
      return { to: match[0], from: null }
    }

    return { from: null, to: null }
  }

  // 1. Bank Details Extraction
  for (let i = 0; i < Math.min(rawData.length, 15); i++) {
    const row = rawData[i]
    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = row[key]
        if (value) {
          const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
          const nextValue = row[nextKey]

          if (typeof value === 'string') {
            const lowerValue = value.toLowerCase()

            // Helper to extract value after colon
            function extractAfterColon(str) {
              const idx = str.indexOf(':')
              if (idx !== -1) {
                return str.slice(idx + 1).trim()
              }
              return null
            }

            if (lowerValue.includes('bank name')) {
              bank_details.bank_name = extractAfterColon(value) || nextValue || null
            } else if (lowerValue.includes('account holder name') || lowerValue.includes('account name')) {
              bank_details.account_holder_name = extractAfterColon(value) || nextValue || null
            } else if (lowerValue.includes('account no') || lowerValue.includes('account number')) {
              const afterColon = extractAfterColon(value)
              if (afterColon) {
                bank_details.account_no = afterColon.split(' ')[0]
              } else {
                bank_details.account_no = nextValue || null
              }
            } else if (lowerValue.includes('ifsc')) {
              // Try to extract after colon
              let afterColon = value.split(':')[1]
              if (afterColon) {
                const ifscMatch = afterColon.match(/[A-Z]{4}0[A-Z0-9]{6}/i)
                if (ifscMatch) {
                  bank_details.ifsc = ifscMatch[0].toUpperCase()
                }
              }
              // Fallback: match IFSC pattern anywhere in the value
              if (!bank_details.ifsc) {
                const ifscMatch = value.match(/[A-Z]{4}0[A-Z0-9]{6}/i)
                if (ifscMatch) {
                  bank_details.ifsc = ifscMatch[0].toUpperCase()
                }
              }
              // Fallback: check nextValue
              if (!bank_details.ifsc && nextValue && typeof nextValue === 'string') {
                const ifscMatch = nextValue.match(/[A-Z]{4}0[A-Z0-9]{6}/i)
                if (ifscMatch) {
                  bank_details.ifsc = ifscMatch[0].toUpperCase()
                }
              }
            } else if (lowerValue.includes('branch name') || lowerValue.includes('account branch')) {
              bank_details.branch_name = extractAfterColon(value) || nextValue || null
            } else if (lowerValue.includes('branch code') || lowerValue.includes('account branch code')) {
              bank_details.branch_code = extractAfterColon(value) || nextValue || null
            } else if (lowerValue.includes('address')) {
              const afterColon = extractAfterColon(value)
              if (afterColon) {
                bank_details.address = (bank_details.address || '') + afterColon + (nextValue || '')
              } else {
                bank_details.address = (bank_details.address || '') + value + (nextValue || '')
              }
            } else if (lowerValue.includes('city')) {
              bank_details.city = extractAfterColon(value) || nextValue || null
            } else if (lowerValue.includes('opening balance')) {
              let balValue = null
              const afterColon = extractAfterColon(value)
              if (afterColon) {
                balValue = parseFloat(afterColon.replace(/[^0-9.-]+/g, ''))
              } else {
                balValue = typeof nextValue === 'number' ? nextValue : parseFloat((nextValue + '').replace(/[^0-9.-]+/g, ''))
              }
              bank_details.opening_balance = !isNaN(balValue) ? balValue : 0
            }
          }
        }
      }
    }
  }

  // Universal fallback for IFSC extraction
  if (!bank_details.ifsc) {
    for (let i = 0; i < Math.min(rawData.length, 15); i++) {
      const row = rawData[i]
      for (const key in row) {
        if (row.hasOwnProperty(key)) {
          const value = row[key]
          if (typeof value === 'string') {
            const lower = value.toLowerCase()
            if (
              lower.includes('ifsc') ||
              lower.includes('ifs') ||
              lower.includes('rtgs/neft ifsc')
            ) {
              // Try after colon
              let afterColon = value.split(':')[1]
              if (afterColon) {
                const ifscMatch = afterColon.match(/[A-Z]{4}0[A-Z0-9]{6}/i)
                if (ifscMatch) {
                  bank_details.ifsc = ifscMatch[0].toUpperCase()
                  break
                }
              }
              // Fallback: match IFSC pattern anywhere in the value
              const ifscMatch = value.match(/[A-Z]{4}0[A-Z0-9]{6}/i)
              if (ifscMatch) {
                bank_details.ifsc = ifscMatch[0].toUpperCase()
                break
              }
            }
          }
        }
      }
      if (bank_details.ifsc) break
    }
  }

  if (!bank_details.account_holder_name) {
    // Fallback: scan for a likely name in the first 15 rows
    const namePrefixes = ['mr', 'ms', 'mrs', 'miss', 'shri', 'smt']
    for (let i = 0; i < Math.min(rawData.length, 15); i++) {
      const row = rawData[i]
      for (const key in row) {
        if (row.hasOwnProperty(key)) {
          const value = row[key]
          if (typeof value === 'string') {
            const trimmed = value.trim()
            const lower = trimmed.toLowerCase()
            // Heuristic: starts with a name prefix and is not a keyword
            if (
              namePrefixes.some(prefix => lower.startsWith(prefix + ' ')) &&
              !lower.includes('account') &&
              !lower.includes('bank') &&
              !lower.includes('branch') &&
              !lower.includes('ifsc') &&
              !lower.includes('address') &&
              !lower.includes('city') &&
              !lower.includes('balance')
            ) {
              bank_details.account_holder_name = trimmed.replace(/\s+/g, ' ')
              break
            }
          }
        }
      }
      if (bank_details.account_holder_name) break
    }
  }

  // 2. Header Row Identification & Key Mapping
  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    let dateFound = false
    let narrationFound = false
    let debitFound = false
    let creditFound = false
    let balanceFound = false

    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = row[key]
        if (typeof value === 'string') {
          const lowerValue = value.toLowerCase().trim()
          if (lowerValue.includes('date')) {
            keyMap.dateKey = key
            dateFound = true
          } else if (lowerValue.includes('narration') || lowerValue.includes('description') || lowerValue.includes('details')) {
            keyMap.narrationKey = key
            narrationFound = true
          } else if (lowerValue.includes('withdrawal') || lowerValue.includes('debit')) {
            keyMap.debitKey = key
            debitFound = true
          } else if (lowerValue.includes('deposit') || lowerValue.includes('credit')) {
            keyMap.creditKey = key
            creditFound = true
          } else if (lowerValue.includes('balance') || lowerValue.includes('closing balance')) {
            keyMap.balanceKey = key
            balanceFound = true
          }
        }
      }
    }

    if (dateFound && narrationFound && (debitFound || creditFound) && balanceFound) {
      headerRowIndex = i
      break
    }
  }

  // 3. Transaction Processing
  if (headerRowIndex !== -1) {
    for (let i = headerRowIndex + 1; i < rawData.length; i++) {
      const row = rawData[i]
      if (!row || Object.keys(row).length === 0) continue // Skip empty rows

      const dateString = row[keyMap.dateKey]
      const desc = row[keyMap.narrationKey] ? (row[keyMap.narrationKey] + '').trim() : null
      const debitValue = row[keyMap.debitKey]
      const creditValue = row[keyMap.creditKey]
      const balanceValue = row[keyMap.balanceKey]
      const date = parseDate(dateString)

      if (!date || (!debitValue && !creditValue && debitValue !== 0 && creditValue !== 0) || !balanceValue) continue // Skip invalid transaction rows

      let amount = null
      let type = null
      if (debitValue && typeof debitValue !== 'string' && !isNaN(parseFloat(debitValue))) {
        amount = Math.abs(parseFloat((debitValue + '').replace(/[^0-9.-]+/g, '')))
        type = 'withdrawal'
      } else if (creditValue && typeof creditValue !== 'string' && !isNaN(parseFloat(creditValue))) {
        amount = Math.abs(parseFloat((creditValue + '').replace(/[^0-9.-]+/g, '')))
        type = 'deposit'
      }

      if (amount === null || type === null) {
        if (typeof debitValue === 'string' || typeof creditValue === 'string') {
          //Skip rows where the debit/credit values are strings, but not convertible to numeric values.
          continue
        }
        //At least one must exist and must be converted to a valid number to constitute a transaction
        continue
      }
      const balValue = typeof balanceValue === 'number' ? balanceValue : parseFloat((balanceValue + '').replace(/[^0-9.-]+/g, ''))

      if (isNaN(balValue)) continue //Skip rows where closing balance is not a number

      const { from, to } = extractFromDescription(desc)

      transactions.push({
        date: date,
        voucher_number: voucher_number++,
        amount: amount,
        desc: desc,
        from: from,
        to: to,
        type: type,
        balance: balValue,
      })
    }
  }

  return { bank_details: bank_details, transactions: transactions }
}

module.exports = processBankStatement

/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bankDetails = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }

  let headerRowIndex = -1
  let keyMapping = {}
  const transactions = []
  let voucherNumber = 1

  // Helper function to parse date strings
  function parseDate(dateString) {
    if (!dateString) return null

    const excelSerialRegex = /^\d+$/
    if (excelSerialRegex.test(dateString)) {
      const excelSerial = parseInt(dateString, 10)
      const epoch = (excelSerial - (25567 + 1)) * 86400 * 1000
      const date = new Date(epoch)
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`
    }
    const formats = [
      [/(\d{2})\/(\d{2})\/(\d{4})/, '$3-$2-$1'],
      [
        /(\d{2})-(\w{3})-(\d{4})/,
        (match, d, m, y) => {
          const month = new Date(Date.parse(m + ' 1, ' + y)).getMonth() + 1
          return `${y}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`
        },
      ],
      [/(\d{2})-(\d{2})-(\d{4})/, '$3-$2-$1'],
      [/(\d{4})-(\d{2})-(\d{2})/, '$1-$2-$3'],
      [/(\d{2})\.(\d{2})\.(\d{4})/, '$3-$2-$1'],
      [/(\d{1})\/(\d{2})\/(\d{4})/, '$3-$2-$1'],
      [/(\d{2})\/(\d{1})\/(\d{4})/, '$3-$2-$1'],
      [/(\d{4})\/(\d{2})\/(\d{2})/, '$1-$2-$3'],
      [
        /(\d{1})\/(\d{1})\/(\d{4})/,
        (match, d, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`
        },
      ],
      [
        /(\d{2})\/(\d{4})/,
        (match, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-01`
        },
      ],
      [
        /(\d{1})\/(\d{4})/,
        (match, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-01`
        },
      ],
      [
        /(\d{2})-(\d{4})/,
        (match, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-01`
        },
      ],
      [
        /(\d{1})-(\d{4})/,
        (match, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-01`
        },
      ],
      [
        /(\d{2})\.(\d{4})/,
        (match, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-01`
        },
      ],
      [
        /(\d{1})\.(\d{4})/,
        (match, m, y) => {
          return `${y}-${String(m).padStart(2, '0')}-01`
        },
      ],

      [
        /(\d{2}) (\w{3}) (\d{4})/,
        (match, d, m, y) => {
          const month = new Date(Date.parse(m + ' 1, ' + y)).getMonth() + 1
          return `${y}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`
        },
      ],
      [
        /(\d{1}) (\w{3}) (\d{4})/,
        (match, d, m, y) => {
          const month = new Date(Date.parse(m + ' 1, ' + y)).getMonth() + 1
          return `${y}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`
        },
      ],
      [
        /(\w{3}) (\d{2}), (\d{4})/,
        (match, m, d, y) => {
          const month = new Date(Date.parse(m + ' 1, ' + y)).getMonth() + 1
          return `${y}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`
        },
      ],
      [
        /(\w{3}) (\d{1}), (\d{4})/,
        (match, m, d, y) => {
          const month = new Date(Date.parse(m + ' 1, ' + y)).getMonth() + 1
          return `${y}-${String(month).padStart(2, '0')}-${String(d).padStart(2, '0')}`
        },
      ],
    ]

    for (const [regex, replacement] of formats) {
      if (regex.test(dateString)) {
        try {
          return dateString.replace(regex, replacement)
        } catch (error) {
          console.error('Date parsing error:', error)
          return null
        }
      }
    }

    try {
      const date = new Date(dateString)
      if (!isNaN(date)) {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`
      }
    } catch (err) {
      console.error('Date parsing error:', err)
      return null
    }

    return null
  }

  // Helper function to extract number from string
  function extractNumber(str) {
    if (typeof str === 'number') return str
    if (!str) return null
    const cleanedString = str.toString().replace(/[^\d.-]/g, '')
    const parsedNumber = parseFloat(cleanedString)
    return isNaN(parsedNumber) ? null : parsedNumber
  }

  // Extract Bank Details
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = row[key]
        if (typeof value === 'string') {
          const lowerCaseValue = value.toLowerCase()
          if (lowerCaseValue.includes('bank name')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.bank_name = row[nextKey]
            }
          } else if (lowerCaseValue.includes('account no')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.account_no = row[nextKey]
            }
          } else if (lowerCaseValue.includes('account holder name') || lowerCaseValue.includes('primary holder')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.account_holder_name = row[nextKey]
            }
          } else if (lowerCaseValue.includes('ifsc') || lowerCaseValue.includes('ifs')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.ifsc = row[nextKey]
            }
          } else if (lowerCaseValue.includes('branch name')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.branch_name = row[nextKey]
            }
          } else if (lowerCaseValue.includes('address')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.address = row[nextKey]
            }
          } else if (lowerCaseValue.includes('city')) {
            const nextKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
            if (nextKey && row[nextKey]) {
              bankDetails.city = row[nextKey]
            }
          }
        }
      }
    }
  }

  // Identify Header Row and Create Key Mapping
  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    let hasDate = false
    let hasNarration = false
    let hasDebit = false
    let hasCredit = false
    let hasBalance = false

    for (const key in row) {
      if (row.hasOwnProperty(key) && typeof row[key] === 'string') {
        const lowerCaseValue = row[key].toLowerCase()
        if (lowerCaseValue.includes('date')) {
          hasDate = true
          keyMapping.dateKey = key
        } else if (lowerCaseValue.includes('narration') || lowerCaseValue.includes('description') || lowerCaseValue.includes('details')) {
          hasNarration = true
          keyMapping.narrationKey = key
        } else if (lowerCaseValue.includes('withdrawal') || lowerCaseValue.includes('debit')) {
          hasDebit = true
          keyMapping.debitKey = key
        } else if (lowerCaseValue.includes('deposit') || lowerCaseValue.includes('credit')) {
          hasCredit = true
          keyMapping.creditKey = key
        } else if (lowerCaseValue.includes('balance') || lowerCaseValue.includes('closing balance')) {
          hasBalance = true
          keyMapping.balanceKey = key
        }
      }
    }

    if (hasDate && hasNarration && (hasDebit || hasCredit) && hasBalance) {
      headerRowIndex = i
      break
    }
  }

  // Process Transactions
  if (headerRowIndex !== -1) {
    for (let i = headerRowIndex + 1; i < rawData.length; i++) {
      const row = rawData[i]
      if (!row) continue

      const dateValue = row[keyMapping.dateKey]
      const desc = row[keyMapping.narrationKey] ? String(row[keyMapping.narrationKey]).trim() : null
      const debitValue = row[keyMapping.debitKey]
      const creditValue = row[keyMapping.creditKey]
      const balanceValue = row[keyMapping.balanceKey]

      const date = parseDate(dateValue)
      const debit = extractNumber(debitValue)
      const credit = extractNumber(creditValue)
      const balance = extractNumber(balanceValue)

      if (!date || (!debit && !credit) || balance === null) {
        continue
      }

      let type = null
      let amount = null

      if (debit !== null) {
        type = 'withdrawal'
        amount = Math.abs(debit)
      } else if (credit !== null) {
        type = 'deposit'
        amount = Math.abs(credit)
      } else {
        continue
      }

      let from = null
      let to = null

      transactions.push({
        date: date,
        voucher_number: voucherNumber++,
        amount: amount,
        desc: desc,
        from: from,
        to: to,
        type: type,
        balance: balance,
      })
    }
  }

  return {
    bank_details: bankDetails,
    transactions: transactions,
  }
}

module.exports = processBankStatement

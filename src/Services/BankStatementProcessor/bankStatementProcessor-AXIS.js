/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }
  const headerKeywords = [
    'Date',
    'Narration',
    'Description',
    'Details',
    'Particulars',
    'Withdrawal',
    'Dr',
    'Debit',
    'Deposit',
    'Cr',
    'Credit',
    'Balance',
    'Bal',
    'Closing Balance',
  ]
  let headerRowIndex = -1
  let keyMapping = {}
  let transactions = []
  let voucher_number = 1

  // Function to parse date and format as YYYY-MM-DD
  function parseAndFormatDate(dateString) {
    if (!dateString) return null

    const excelSerialDateRegex = /^\d+$/

    if (excelSerialDateRegex.test(dateString)) {
      const excelSerialDate = parseInt(dateString, 10)
      const epochDays = excelSerialDate - 25569 // Adjust for Excel epoch
      const epochMilliseconds = epochDays * 24 * 60 * 60 * 1000
      const date = new Date(epochMilliseconds)
      const year = date.getFullYear()
      const month = String(date.getMonth() + 1).padStart(2, '0')
      const day = String(date.getDate()).padStart(2, '0')
      return `${year}-${month}-${day}`
    }
    const formats = [
      { regex: /(\d{2})\/(\d{2})\/(\d{4})/, format: '$3-$2-$1' },
      {
        regex: /(\d{2})-(\w{3})-(\d{4})/,
        format: (match) => {
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
          const monthIndex = monthNames.findIndex((month) => month.toLowerCase() === match[2].toLowerCase())
          if (monthIndex === -1) return null
          const month = String(monthIndex + 1).padStart(2, '0')
          return `${match[3]}-${month}-${match[1]}`
        },
      },
      {
        regex: /(\d{2})\/(\d{2})\/(\d{2})/,
        format: (match) => {
          const yearPrefix = '20'
          return `${yearPrefix}${match[3]}-${match[2]}-${match[1]}`
        },
      },
      { regex: /(\d{4})-(\d{2})-(\d{2})/, format: '$1-$2-$3' },
      { regex: /(\d{2})-(\d{2})-(\d{4})/, format: '$3-$2-$1' },
      { regex: /(\d{2})\.(\d{2})\.(\d{4})/, format: '$3-$2-$1' },
      {
        regex: /(\d{2})-(\d{2})-(\d{2})/,
        format: (match) => {
          const yearPrefix = '20'
          return `${yearPrefix}${match[3]}-${match[2]}-${match[1]}`
        },
      },
      {
        regex: /(\d{2})\.(\d{2})\.(\d{2})/,
        format: (match) => {
          const yearPrefix = '20'
          return `${yearPrefix}${match[3]}-${match[2]}-${match[1]}`
        },
      },
      { regex: /(\d{4})\/(\d{2})\/(\d{2})/, format: '$1-$2-$3' },
      {
        regex: /(\d{2})-(\w+)-(\d{2})/,
        format: (match) => {
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
          const monthIndex = monthNames.findIndex((month) => month.toLowerCase() === match[2].toLowerCase())
          if (monthIndex === -1) return null
          const month = String(monthIndex + 1).padStart(2, '0')
          const yearPrefix = '20'

          return `${yearPrefix}${match[3]}-${month}-${match[1]}`
        },
      },
      {
        regex: /(\d{2})\s([a-zA-Z]+)\s(\d{4})/,
        format: (match) => {
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
          const monthIndex = monthNames.findIndex((month) => month.toLowerCase() === match[2].toLowerCase())
          if (monthIndex === -1) return null
          const month = String(monthIndex + 1).padStart(2, '0')
          return `${match[3]}-${month}-${match[1]}`
        },
      },
    ]

    for (const format of formats) {
      const match = dateString.match(format.regex)
      if (match) {
        if (typeof format.format === 'string') {
          return dateString.replace(format.regex, format.format)
        } else if (typeof format.format === 'function') {
          const formattedDate = format.format(match)
          if (formattedDate) return formattedDate
        }
      }
    }

    return null
  }

  function extractNumber(value) {
    if (!value) return null
    const cleanedValue = String(value).replace(/[^\d.-]/g, '')
    const number = parseFloat(cleanedValue)
    return isNaN(number) ? null : number
  }

  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = String(row[key]).trim()

        if (value.toLowerCase().includes('ifsc') || value.toLowerCase().includes('ifs')) {
          const ifscKey = Object.keys(row).find((k) => k !== key)
          if (ifscKey && row[ifscKey]) {
            bank_details.ifsc = String(row[ifscKey]).replace(/^[-:]+\s*/, '').trim()
          } else {
            const ifscValue = value.split(':').pop().replace(/^[-:]+\s*/, '').trim()
            bank_details.ifsc = ifscValue
          }
        }

        if (value.toLowerCase().includes('bank name')) {
          const bankNameKey = Object.keys(row).find((k) => k !== key)
          if (bankNameKey && row[bankNameKey]) {
            bank_details.bank_name = String(row[bankNameKey]).trim()
          }
        }
        if (value.toLowerCase().includes('account no')) {
          const accountNoKey = Object.keys(row).find((k) => k !== key)
          if (accountNoKey && row[accountNoKey]) {
            bank_details.account_no = String(row[accountNoKey]).trim()
          }
        }
        if (value.toLowerCase().includes('name') || value.toLowerCase().includes('account holder name') || value.toLowerCase().includes('holder name')) {
          const accountHolderNameKey = Object.keys(row).find((k) => k !== key)
          if (accountHolderNameKey && row[accountHolderNameKey]) {
            bank_details.account_holder_name = String(row[accountHolderNameKey]).trim()
          } else {
            // Try to extract the name from the value itself, e.g., 'Name :- BOTHRA  GARIMA'
            const match = value.match(/name\s*[:-]?\s*(.+)/i)
            if (match && match[1]) {
              bank_details.account_holder_name = match[1].replace(/^[-:]+\s*/, '').trim()
            }
          }
        }

        if (value.toLowerCase().includes('opening balance')) {
          const openingBalanceKey = Object.keys(row).find((k) => k !== key)
          if (openingBalanceKey && row[openingBalanceKey]) {
            const openingBalanceValue = extractNumber(row[openingBalanceKey])
            if (openingBalanceValue !== null) {
              bank_details.opening_balance = openingBalanceValue
            }
          }
        }
        if (value.toLowerCase().includes('branch name')) {
          const branchNameKey = Object.keys(row).find((k) => k !== key)
          if (branchNameKey && row[branchNameKey]) {
            bank_details.branch_name = String(row[branchNameKey]).trim()
          }
        }
      }
    }
  }
  if (!bank_details.ifsc) {
    for (let i = 0; i < Math.min(20, rawData.length); i++) {
      const row = rawData[i]
      for (const key in row) {
        if (row.hasOwnProperty(key)) {
          const value = String(row[key]).trim()
          if (value.toLowerCase().includes('ifsc') || value.toLowerCase().includes('ifs')) {
            const ifscValue = value.split(':').pop().replace(/^[-:]+\s*/, '').trim()
            bank_details.ifsc = ifscValue
          }
        }
      }
    }
  }

  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    let headerMatchCount = 0
    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = String(row[key]).trim()
        if (headerKeywords.some((keyword) => value.toLowerCase().includes(keyword.toLowerCase()))) {
          headerMatchCount++
        }
      }
    }
    if (headerMatchCount >= 2) {
      headerRowIndex = i
      for (const key in row) {
        if (row.hasOwnProperty(key)) {
          const value = String(row[key]).trim()
          if (value.toLowerCase().includes('date')) {
            keyMapping.dateKey = key
          } else if (
            value.toLowerCase().includes('narration') ||
            value.toLowerCase().includes('description') ||
            value.toLowerCase().includes('details') ||
            value.toLowerCase().includes('particulars')
          ) {
            keyMapping.narrationKey = key
          } else if (value.toLowerCase().includes('debit') || value.toLowerCase().includes('dr') || value.toLowerCase().includes('withdrawal')) {
            keyMapping.debitKey = key
          } else if (value.toLowerCase().includes('credit') || value.toLowerCase().includes('cr') || value.toLowerCase().includes('deposit')) {
            keyMapping.creditKey = key
          } else if (
            value.toLowerCase().includes('balance') ||
            value.toLowerCase().includes('bal') ||
            value.toLowerCase().includes('closing balance')
          ) {
            keyMapping.balanceKey = key
          }
        }
      }
      break
    }
  }

  if (headerRowIndex !== -1) {
    for (let i = headerRowIndex + 1; i < rawData.length; i++) {
      const row = rawData[i]
      if (!row) continue
      let hasData = false
      for (const key in row) {
        if (row.hasOwnProperty(key) && row[key] !== null && row[key] !== undefined && String(row[key]).trim() !== '') {
          hasData = true
          break
        }
      }
      if (!hasData) continue

      const date = row[keyMapping.dateKey] ? parseAndFormatDate(String(row[keyMapping.dateKey]).trim()) : null
      const desc = row[keyMapping.narrationKey] ? String(row[keyMapping.narrationKey]).trim() : null
      const debitValue = keyMapping.debitKey && row[keyMapping.debitKey] ? extractNumber(row[keyMapping.debitKey]) : null
      const creditValue = keyMapping.creditKey && row[keyMapping.creditKey] ? extractNumber(row[keyMapping.creditKey]) : null
      const balanceValue = keyMapping.balanceKey && row[keyMapping.balanceKey] ? extractNumber(row[keyMapping.balanceKey]) : null

      let type = null
      let amount = null

      if (debitValue !== null) {
        type = 'withdrawal'
        amount = Math.abs(debitValue)
      } else if (creditValue !== null) {
        type = 'deposit'
        amount = Math.abs(creditValue)
      }

      if (date && (type === 'withdrawal' || type === 'deposit')) {
        transactions.push({
          date: date,
          voucher_number: voucher_number++,
          amount: amount,
          desc: desc,
          from: null,
          to: null,
          type: type,
          balance: balanceValue !== null ? balanceValue : null,
        })
      }
    }
  }

  return {
    bank_details: bank_details,
    transactions: transactions,
  }
}

module.exports = processBankStatement

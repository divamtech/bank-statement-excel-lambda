/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }
  const transaction_keywords = [
    'date',
    'narration',
    'description',
    'details',
    'particulars',
    'withdrawal',
    'dr',
    'debit',
    'deposit',
    'cr',
    'credit',
    'balance',
    'bal',
    'closing balance',
  ]
  let headerRowIndex = -1
  let keyMapping = {}
  let transactions = []
  let voucher_number = 1

  // Extract Bank Details (improved for array rows)
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    if (Array.isArray(row)) {
      // Handle Account Number row
      if (typeof row[0] === 'string' && row[0].toLowerCase().includes('account number')) {
        // Find first non-null, numeric value
        for (let j = 1; j < row.length; j++) {
          if (row[j] !== null && !isNaN(row[j]) && String(row[j]).length >= 6) {
            bank_details.account_no = String(row[j]).trim()
            break
          }
        }
      }
      // Handle Account Name\nAddress row
      if (typeof row[0] === 'string' && row[0].toLowerCase().includes('account name')) {
        // Find first non-null string value
        for (let j = 1; j < row.length; j++) {
          if (row[j] && typeof row[j] === 'string') {
            // Split by \n
            const parts = row[j].split('\n').map(s => s.trim()).filter(Boolean)
            if (parts.length > 0) {
              // First line is name
              bank_details.account_holder_name = parts[0]
              // Try to find address in last line or after last comma
              const lastLine = parts[parts.length - 1]
              // If last line contains a comma, take after last comma
              if (lastLine.includes(',')) {
                bank_details.address = lastLine.substring(lastLine.lastIndexOf(',') + 1).trim()
              } else {
                bank_details.address = lastLine
              }
            }
            break
          }
        }
      }
      // Handle IFS Code row
      if (typeof row[0] === 'string' && (row[0].toLowerCase().includes('ifs code') || row[0].toLowerCase().includes('ifsc'))) {
        for (let j = 1; j < row.length; j++) {
          if (row[j] && typeof row[j] === 'string' && /[A-Z]{4}0[A-Z0-9]{6}/i.test(row[j])) {
            bank_details.ifsc = row[j].toUpperCase()
            break
          }
        }
      }
      // Handle Branch row
      if (typeof row[0] === 'string' && row[0].toLowerCase().includes('branch')) {
        for (let j = 1; j < row.length; j++) {
          if (row[j] && typeof row[j] === 'string') {
            bank_details.branch_name = row[j]
            break
          }
        }
      }
    } else {
      // Fallback: original object-row logic
      for (const key in row) {
        if (row.hasOwnProperty(key) && row[key] != null) {
          const value = String(row[key]).trim()
          if (value.toLowerCase().includes('bank name')) {
            bank_details.bank_name = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]]).trim() || bank_details.bank_name
          } else if (value.toLowerCase().includes('account holder name') || value.toLowerCase().includes('account name')) {
            bank_details.account_holder_name = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]]).trim() || bank_details.account_holder_name
          } else if (value.toLowerCase().includes('account no') || value.toLowerCase().includes('account number')) {
            bank_details.account_no = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]]).trim() || bank_details.account_no
          } else if (value.toLowerCase().includes('ifsc') || value.toLowerCase().includes('ifs')) {
            bank_details.ifsc = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]]).trim() || bank_details.ifsc
          } else if (value.toLowerCase().includes('branch name')) {
            bank_details.branch_name = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]]).trim() || bank_details.branch_name
          } else if (value.toLowerCase().includes('address')) {
            bank_details.address = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]]).trim() || bank_details.address
          }
        }
      }
    }
  }

  //Find Opening Balance
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    for (const key in row) {
      if (row.hasOwnProperty(key) && row[key] != null) {
        const value = String(row[key]).trim()
        if (value.toLowerCase().includes('opening balance') || value.toLowerCase().includes('balance as on')) {
          const openingBalanceString = String(row[Object.keys(row)[Object.keys(row).indexOf(key) + 1]])
          const balanceMatch = openingBalanceString?.match(/[-+]?[\d,.]+/)
          if (balanceMatch) {
            bank_details.opening_balance = parseFloat(balanceMatch[0].replace(/,/g, ''))
          }
        }
      }
    }
  }

  // Identify Header Row
  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    let headerMatchCount = 0
    for (const key in row) {
      if (row.hasOwnProperty(key) && row[key] != null) {
        const value = String(row[key]).trim().toLowerCase()
        if (transaction_keywords.includes(value)) {
          headerMatchCount++
        }
      }
    }
    if (headerMatchCount >= 2) {
      headerRowIndex = i
      for (const key in row) {
        if (row.hasOwnProperty(key) && row[key] != null) {
          const value = String(row[key]).trim().toLowerCase()
          if (value.includes('date')) {
            keyMapping['dateKey'] = key
          } else if (value.includes('narration') || value.includes('description') || value.includes('details') || value.includes('particulars')) {
            keyMapping['narrationKey'] = key
          } else if (value.includes('withdrawal') || value.includes('dr') || value.includes('debit')) {
            keyMapping['debitKey'] = key
          } else if (value.includes('deposit') || value.includes('cr') || value.includes('credit')) {
            keyMapping['creditKey'] = key
          } else if (value.includes('balance') || value.includes('bal')) {
            keyMapping['balanceKey'] = key
          }
        }
      }
      break
    }
  }

  // Process Transactions
  if (headerRowIndex !== -1) {
    for (let i = headerRowIndex + 1; i < rawData.length; i++) {
      const row = rawData[i]
      if (!row) continue

      let date = row[keyMapping['dateKey']] || null
      let desc = row[keyMapping['narrationKey']] || ''
      let debit = row[keyMapping['debitKey']] || null
      let credit = row[keyMapping['creditKey']] || null
      let balance = row[keyMapping['balanceKey']] || null

      if (!date && !desc && !debit && !credit && !balance) continue

      let amount = null
      let type = null

      if (debit && typeof debit === 'string' && debit.trim() !== '-' && debit.trim() !== '') {
        amount = parseFloat(String(debit).replace(/[^0-9.-]+/g, ''))
        type = 'withdrawal'
      }

      if (credit && typeof credit === 'string' && credit.trim() !== '-' && credit.trim() !== '') {
        amount = parseFloat(String(credit).replace(/[^0-9.-]+/g, ''))
        type = 'deposit'
      }

      if (debit && typeof debit === 'number') {
        amount = parseFloat(String(debit).replace(/[^0-9.-]+/g, ''))
        type = 'withdrawal'
      }

      if (credit && typeof credit === 'number') {
        amount = parseFloat(String(credit).replace(/[^0-9.-]+/g, ''))
        type = 'deposit'
      }

      if (amount === null) continue

      if (type === null) continue

      if (date) {
        try {
          if (typeof date === 'string') {
            let parsedDate = new Date(date)
            if (isNaN(parsedDate.getTime())) {
              const excelSerialDate = parseInt(date, 10)
              if (!isNaN(excelSerialDate)) {
                parsedDate = new Date((excelSerialDate - (25567 + 1)) * 86400 * 1000)
              } else {
                parsedDate = null
              }
            }
            if (parsedDate) {
              date = parsedDate.toISOString().slice(0, 10)
            } else {
              date = null
            }
          } else {
            date = new Date(date).toISOString().slice(0, 10)
          }
        } catch (e) {
          date = null
        }
      }

      if (balance) {
        try {
          balance = parseFloat(String(balance).replace(/[^0-9.-]+/g, ''))
        } catch (e) {
          balance = null
        }
      } else {
        balance = null
      }

      desc = String(desc).trim()

      const transaction = {
        date: date || null,
        voucher_number: voucher_number++,
        amount: Math.abs(amount),
        desc: desc || null,
        from: null,
        to: null,
        type: type,
        balance: balance || null,
      }

      transactions.push(transaction)
    }
  }

  return {
    bank_details: bank_details,
    transactions: transactions,
  }
}

module.exports = processBankStatement

/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bankDetails = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }
  const transactions = []
  let headerRowIndex = -1
  let keyMap = {}

  // Extract Bank Details
  const extracted = extractBankDetailsFromArray(rawData[1])
  console.log('extracted::', extracted)
  Object.assign(bankDetails, extracted)

  // Helper function to parse date
  function parseDate(dateString) {
    if (!dateString) return null

    try {
      // Try different date formats
      let date = new Date(dateString)

      if (isNaN(date.getTime())) {
        // Attempt to parse Excel serial date
        const excelSerialDate = parseInt(dateString, 10)
        if (!isNaN(excelSerialDate)) {
          date = excelSerialDateToJSDate(excelSerialDate)
        } else {
          return null // Invalid date
        }
      }

      const year = date.getFullYear()
      const month = String(date.getMonth() + 1).padStart(2, '0')
      const day = String(date.getDate()).padStart(2, '0')
      return `${year}-${month}-${day}`
    } catch (error) {
      return null
    }
  }

  function excelSerialDateToJSDate(serial) {
    return new Date(Date.UTC(1899, 11, 30 + serial))
  }

  // Helper function to extract bank details from an array of strings
  function extractBankDetailsFromArray(detailsArray) {

    const details = {
      bank_name: null,
      opening_balance: 0,
      ifsc: null,
      address: null,
      city: null,
      account_no: null,
      account_holder_name: null,
      branch_name: null,
      branch_code: null,
      micr: null,
      email: null,
      customer_id: null,
      open_date: null,
      scheme_code: null,
      status: null,
    };
    if (!Array.isArray(detailsArray)) return details;
    for (const str of detailsArray) {
      if (!str || typeof str !== 'string') continue;
      // Account Number and Holder Name
      const accMatch = str.match(/Account Number\s*[-:]?\s*(\d+)\s+([A-Z ]+)/i);
      if (accMatch) {
        details.account_no = accMatch[1];
        details.account_holder_name = accMatch[2].trim();
      }
      // Customer Id
      const custIdMatch = str.match(/Customer Id\s*[:\-]?\s*(\d+)/i);
      if (custIdMatch) details.customer_id = custIdMatch[1];
      // Open Date
      const openDtMatch = str.match(/Open Dt\s*[:\-]?\s*([0-9\/\-]+)/i);
      if (openDtMatch) details.open_date = openDtMatch[1];
      // Scheme Code
      const schemeMatch = str.match(/Scheme Code\s*[:\-]?\s*([A-Z0-9\-]+)/i);
      if (schemeMatch) details.scheme_code = schemeMatch[1];
      // Status
      const statusMatch = str.match(/Status\s*[:\-]?\s*([A-Za-z]+)/i);
      if (statusMatch) details.status = statusMatch[1];
      // Address (multi-line)
      if (str.includes('Address')) {
        const addrLines = str.split(/Address\s*[:\-]?/i)[1];
        if (addrLines) {
          details.address = addrLines.replace(/\n+/g, ', ').replace(/\s+/g, ' ').trim();
        }
      }
      // IFSC, MICR, Email
      const ifscMatch = str.match(/IFSC CODE\s*[:\-]?\s*([A-Z0-9]+)/i);
      if (ifscMatch) details.ifsc = ifscMatch[1];
      const micrMatch = str.match(/MICR CODE\s*[:\-]?\s*(\d+)/i);
      if (micrMatch) details.micr = micrMatch[1];
      const emailMatch = str.match(/EMAIL ID\s*[:\-]?\s*([\w.\-@]+)/i);
      if (emailMatch) details.email = emailMatch[1];
      // City (try to extract from address or city line)
      const cityMatch = str.match(/SURAT CITY|MUMBAI|DELHI|BANGALORE|CHENNAI|KOLKATA|HYDERABAD|PUNE|AHMEDABAD|JAIPUR|LUCKNOW|KANPUR|NAGPUR|INDORE|THANE|BHOPAL|VISAKHAPATNAM|PATNA|VADODARA|GHAZIABAD|LUDHIANA|AGRA|NASHIK|FARIDABAD|MEERUT|RAJKOT|KALYAN|VASAI|VARANASI|SRINAGAR|AURANGABAD|DHANBAD|AMRITSAR|NAVI MUMBAI|ALLAHABAD|HOWRAH|RANCHI|GWALIOR|JABALPUR|COIMBATORE|VIJAYAWADA|JODHPUR|MADURAI|RAIPUR|KOTA|GUWAHATI|CHANDIGARH|SOLAPUR|HUBLI|MYSORE|TIRUCHIRAPPALLI|BAREILLY|ALIGARH|TIRUPPUR|MORADABAD|JALANDHAR|BHIWANDI|SAHARANPUR|GORAKHPUR|BIKANER|AMRAVATI|NOIDA|JAMSHEDPUR|BHUBANESWAR|CUTTACK|FATEHPUR|KOLLAM|KANNUR|ERNAKULAM|TRIVANDRUM|KOZHIKODE|THRISSUR|PALAKKAD|KOTTAYAM|ALAPPUZHA|PATHANAMTHITTA|IDUKKI|WAYANAD|KASARAGOD/i);
      if (cityMatch) details.city = cityMatch[0];
      // Branch Name/Code
      const branchMatch = str.match(/SURAT \((\d+)\)/i);
      if (branchMatch) {
        details.branch_name = 'SURAT';
        details.branch_code = branchMatch[1];
      }
    }
    return details;
  }

  // Extract Bank Details
  // const maxBankDetailsRows = Math.min(20, rawData.length)
  // for (let i = 0; i < maxBankDetailsRows; i++) {
  //   const row = rawData[i]
  //   for (const key in row) {
  //     if (row.hasOwnProperty(key)) {
  //       const value = row[key]
  //       if (typeof value === 'string') {
  //         const lowerCaseValue = value.toLowerCase()

  //         if (lowerCaseValue.includes('bank name')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           bankDetails.bank_name = row[adjacentKey] || bankDetails.bank_name
  //         } else if (lowerCaseValue.includes('account holder name')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           bankDetails.account_holder_name = row[adjacentKey] || bankDetails.account_holder_name
  //         } else if (lowerCaseValue.includes('account no') || lowerCaseValue.includes('account number')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           bankDetails.account_no = row[adjacentKey] || bankDetails.account_no
  //         } else if (lowerCaseValue.includes('ifsc') || lowerCaseValue.includes('ifs')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           bankDetails.ifsc = row[adjacentKey] || bankDetails.ifsc
  //         } else if (lowerCaseValue.includes('branch name')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           bankDetails.branch_name = row[adjacentKey] || bankDetails.branch_name
  //         } else if (lowerCaseValue.includes('address')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           bankDetails.address = row[adjacentKey] || bankDetails.address
  //         }

  //         if (lowerCaseValue.includes('opening balance') || lowerCaseValue.includes('opening bal')) {
  //           const adjacentKey = Object.keys(row).find((k) => k !== key)
  //           const balanceValue = row[adjacentKey]
  //           if (typeof balanceValue === 'number') {
  //             bankDetails.opening_balance = balanceValue
  //           } else if (typeof balanceValue === 'string') {
  //             const parsedBalance = parseFloat(balanceValue.replace(/[^0-9.-]+/g, ''))
  //             if (!isNaN(parsedBalance)) {
  //               bankDetails.opening_balance = parsedBalance
  //             }
  //           }
  //         }
  //       }
  //     }
  //   }
  // }

  // Identify Header Row and Create Key Map
  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    let hasDate = false
    let hasNarration = false
    let hasDebit = false
    let hasCredit = false
    let hasBalance = false

    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = row[key]
        if (typeof value === 'string') {
          const lowerCaseValue = value.toLowerCase()
          if (lowerCaseValue.includes('date')) {
            hasDate = true
            keyMap.dateKey = key
          } else if (
            lowerCaseValue.includes('naration') ||
            lowerCaseValue.includes('narration') ||
            lowerCaseValue.includes('description') ||
            lowerCaseValue.includes('details')
          ) {
            hasNarration = true
            keyMap.narrationKey = key
          } else if (lowerCaseValue.includes('debit') || lowerCaseValue.includes('withdrawal')) {
            hasDebit = true
            keyMap.debitKey = key
          } else if (lowerCaseValue.includes('credit') || lowerCaseValue.includes('deposit')) {
            hasCredit = true
            keyMap.creditKey = key
          } else if (lowerCaseValue.includes('balance') || lowerCaseValue.includes('closing balance')) {
            hasBalance = true
            keyMap.balanceKey = key
          }
        }
      }
    }

    if (hasDate && hasNarration && (hasDebit || hasCredit) && hasBalance) {
      headerRowIndex = i
      break
    }
  }

  // Process Transactions
  let voucherNumber = 1
  for (let i = headerRowIndex + 1; i < rawData.length; i++) {
    const row = rawData[i]
    if (!row) continue

    const dateValue = row[keyMap.dateKey]
    const narrationValue = row[keyMap.narrationKey]
    const debitValue = row[keyMap.debitKey]
    const creditValue = row[keyMap.creditKey]
    const balanceValue = row[keyMap.balanceKey]

    if (!dateValue && !narrationValue && !debitValue && !creditValue && !balanceValue) {
      continue
    }
    const date = parseDate(dateValue)
    if (!date) continue

    const desc = typeof narrationValue === 'string' ? narrationValue.trim() : null

    let amount = null
    let type = null

    if (debitValue !== null && debitValue !== undefined) {
      const debit = typeof debitValue === 'number' ? debitValue : parseFloat(String(debitValue).replace(/[^0-9.-]+/g, ''))

      if (!isNaN(debit) && debit > 0) {
        amount = debit
        type = 'withdrawal'
      }
    }

    if (creditValue !== null && creditValue !== undefined && (amount === null || type === null)) {
      const credit = typeof creditValue === 'number' ? creditValue : parseFloat(String(creditValue).replace(/[^0-9.-]+/g, ''))

      if (!isNaN(credit) && credit > 0) {
        amount = credit
        type = 'deposit'
      }
    }

    if (amount === null || type === null) continue

    const balance = typeof balanceValue === 'number' ? balanceValue : parseFloat(String(balanceValue).replace(/[^0-9.-]+/g, ''))
    if (isNaN(balance)) continue

    const transaction = {
      date: date,
      voucher_number: voucherNumber,
      amount: amount,
      desc: desc,
      from: null,
      to: null,
      type: type,
      balance: balance,
    }

    transactions.push(transaction)
    voucherNumber++
  }
  if (!bankDetails.ifsc) {
    bankDetails.ifsc = null
  }

  return {
    bank_details: bankDetails,
    transactions: transactions,
  }
}

module.exports = processBankStatement

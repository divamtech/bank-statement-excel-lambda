/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }
  const transactionHeaders = [
    'Date',
    'Narration',
    'Description',
    'Details',
    'Particulars',
    'Withdrawal',
    'Dr',
    'Debit',
    'Deposit',
    'Cr',
    'Credit',
    'Balance',
    'Bal',
    'Closing Balance',
  ]
  let headerRowIndex = -1
  let keyMapping = {}
  const transactions = []
  let voucherNumber = 1

  // Helper function to parse dates
  function parseDate(dateString) {
    if (!dateString) return null;
    try {
      let date;
      if (typeof dateString === 'number') {
        // Excel date serial number (only accept reasonable range)
        if (dateString > 40000 && dateString < 50000) {
          date = new Date(Math.round((dateString - 25569) * 86400 * 1000));
        } else {
          return null;
        }
      } else if (typeof dateString === 'string') {
        // Handle DD-MM-YYYY or DD/MM/YYYY
        const dashMatch = dateString.match(/^(\d{2})[-\/](\d{2})[-\/](\d{4})$/);
        if (dashMatch) {
          const day = parseInt(dashMatch[1], 10);
          const month = parseInt(dashMatch[2], 10);
          const year = parseInt(dashMatch[3], 10);
          if (month > 0 && month <= 12 && day > 0 && day <= 31 && year > 1970 && year < 2100) {
            date = new Date(year, month - 1, day);
          } else {
            return null;
          }
        } else {
          // fallback: try Date.parse
          const parsed = Date.parse(dateString);
          if (!isNaN(parsed)) {
            date = new Date(parsed);
          } else {
            return null;
          }
        }
      } else {
        return null;
      }

      if (!date || isNaN(date) || date.getFullYear() < 1970) {
        return null;
      }

      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    } catch (e) {
      return null;
    }
  }

  // Helper function to extract numeric value
  function extractNumericValue(value) {
    if (!value) return null
    try {
      const cleanedValue = String(value).replace(/[^0-9.-]+/g, '')
      const num = parseFloat(cleanedValue)
      return isNaN(num) ? null : num
    } catch (e) {
      return null
    }
  }

  // Extract bank details (array row version)
  const labelMap = {
    'branch name:': 'branch_name',
    'city:': 'city',
    'ifsc code:': 'ifsc',
    'account name:': 'account_holder_name',
    'account holder name:': 'account_holder_name',
    'account no:': 'account_no',
    'account number:': 'account_no',
    'bank name:': 'bank_name',
    'branch code:': 'branch_code',
    'address:': 'address',
    'bank address:': 'address',
    'customer address:': 'address',
  }
  const foundLabels = {}
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    if (!Array.isArray(row)) continue
    for (let j = 0; j < row.length; j++) {
      const cell = row[j]
      if (typeof cell === 'string') {
        const label = cell.trim().toLowerCase()
        if (labelMap[label] && !foundLabels[labelMap[label]]) {
          // Find the next non-null, non-label value
          for (let k = j + 1; k < row.length; k++) {
            const value = row[k]
            if (typeof value === 'string' && value.trim() && value.trim().toLowerCase() !== label) {
              bank_details[labelMap[label]] = value.trim()
              foundLabels[labelMap[label]] = true
              break
            }
          }
        }
      }
    }
  }

  // Additional extraction: Account Number from statement line in array rows
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i];
    if (!Array.isArray(row)) continue;
    for (let j = 0; j < row.length; j++) {
      const cell = row[j];
      if (typeof cell === 'string' && cell.includes('Account Number')) {
        const match = cell.match(/Account Number\s*(\d{10,20})/i);
        if (match && match[1] && !bank_details.account_no) {
          bank_details.account_no = match[1].trim();
        }
      }
    }
  }

  // Fallback to object row version if not found
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    if (!row || Array.isArray(row)) continue
    for (const key in row) {
      if (!row.hasOwnProperty(key)) continue
      const value = row[key]
      if (typeof value !== 'string') continue

      const lowerCaseValue = value.toLowerCase()
      if (lowerCaseValue.includes('bank name') && !bank_details.bank_name) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.bank_name = String(row[adjacentKey]).trim()
        }
      } else if ((lowerCaseValue.includes('account holder name') || lowerCaseValue.includes('account name')) && !bank_details.account_holder_name) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.account_holder_name = String(row[adjacentKey]).trim()
        }
      } else if ((lowerCaseValue.includes('account no') || lowerCaseValue.includes('account number')) && !bank_details.account_no) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.account_no = String(row[adjacentKey]).trim()
        }
      } else if ((lowerCaseValue.includes('ifsc') || lowerCaseValue.includes('ifs')) && !bank_details.ifsc) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.ifsc = String(row[adjacentKey]).trim()
        }
      } else if (lowerCaseValue.includes('branch name') && !bank_details.branch_name) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.branch_name = String(row[adjacentKey]).trim()
        }
      } else if (lowerCaseValue.includes('branch code') && !bank_details.branch_code) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.branch_code = String(row[adjacentKey]).trim()
        }
      } else if (lowerCaseValue.includes('address') && !bank_details.address) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.address = String(row[adjacentKey]).trim()
        }
      } else if (lowerCaseValue.includes('city') && !bank_details.city) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          bank_details.city = String(row[adjacentKey]).trim()
        }
      }
    }
  }

  //Find opening balance
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    if (!row) continue
    for (const key in row) {
      if (!row.hasOwnProperty(key)) continue
      const value = row[key]
      if (typeof value !== 'string') continue

      const lowerCaseValue = value.toLowerCase()
      if (lowerCaseValue.includes('opening balance') || lowerCaseValue.includes('previous balance')) {
        const adjacentKey = Object.keys(row)[Object.keys(row).indexOf(key) + 1]
        if (adjacentKey && row[adjacentKey]) {
          const openingBalance = extractNumericValue(row[adjacentKey])
          if (openingBalance !== null) {
            bank_details.opening_balance = openingBalance
          }
        }
      }
    }
  }

  // Identify header row and create key mapping
  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    if (!row) continue
    let headerMatchCount = 0
    for (const key in row) {
      if (!row.hasOwnProperty(key)) continue
      const value = row[key]
      if (typeof value !== 'string') continue
      if (transactionHeaders.some((header) => value.toLowerCase().includes(header.toLowerCase()))) {
        headerMatchCount++
      }
    }
    if (headerMatchCount >= 2) {
      //At least 2 headers found to confirm
      headerRowIndex = i
      for (const key in row) {
        if (!row.hasOwnProperty(key)) continue
        const value = row[key]
        if (typeof value !== 'string') continue
        const lowerCaseValue = value.toLowerCase()
        if (lowerCaseValue.includes('date')) {
          keyMapping.dateKey = key
        } else if (
          lowerCaseValue.includes('narration') ||
          lowerCaseValue.includes('description') ||
          lowerCaseValue.includes('details') ||
          lowerCaseValue.includes('particulars')
        ) {
          keyMapping.narrationKey = key
        } else if (lowerCaseValue.includes('withdrawal') || lowerCaseValue.includes('dr') || lowerCaseValue.includes('debit')) {
          keyMapping.debitKey = key
        } else if (lowerCaseValue.includes('deposit') || lowerCaseValue.includes('cr') || lowerCaseValue.includes('credit')) {
          keyMapping.creditKey = key
        } else if (lowerCaseValue.includes('balance') || lowerCaseValue.includes('bal')) {
          keyMapping.balanceKey = key
        }
      }
      break
    }
  }

  // Process transactions
  if (headerRowIndex !== -1) {
    for (let i = headerRowIndex + 1; i < rawData.length; i++) {
      const row = rawData[i]
      if (!row) continue

      const dateString = row[keyMapping.dateKey]
      const desc = row[keyMapping.narrationKey] ? String(row[keyMapping.narrationKey]).trim() : null
      const debitValue = extractNumericValue(row[keyMapping.debitKey])
      const creditValue = extractNumericValue(row[keyMapping.creditKey])
      const balanceValue = extractNumericValue(row[keyMapping.balanceKey])
      const date = parseDate(dateString)

      if (!date && !desc && debitValue === null && creditValue === null && balanceValue === null) {
        continue // Skip empty or irrelevant rows
      }

      if (date) {
        let type = null
        let amount = null

        if (debitValue !== null) {
          type = 'withdrawal'
          amount = Math.abs(debitValue)
        } else if (creditValue !== null) {
          type = 'deposit'
          amount = Math.abs(creditValue)
        }

        if (type) {
          const transaction = {
            date: date,
            voucher_number: voucherNumber++,
            amount: amount,
            desc: desc,
            from: null,
            to: null,
            type: type,
            balance: balanceValue !== null ? balanceValue : null,
          }
          transactions.push(transaction)
        }
      }
    }
  }

  return {
    bank_details: bank_details,
    transactions: transactions,
  }
}

module.exports = processBankStatement

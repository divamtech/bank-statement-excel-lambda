/**
 * Generated by OpenAI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  // Helper: safely get string
  function s(val) {
    if (val === null || val === undefined) return "";
    if (val instanceof Date) return val.toISOString();
    return String(val);
  }

  // Helper: trim and normalize spaces
  function normSpace(str) {
    return s(str).replace(/\s+/g, " ").trim();
  }

  // Helper: case-insensitive includes
  function includesCI(hay, needle) {
    return s(hay).toLowerCase().includes(s(needle).toLowerCase());
  }

  // Helper: parse number from mixed strings like "1,234.56(Dr) INR"
  function parseNumber(val) {
    if (val === null || val === undefined) return null;
    if (typeof val === "number" && isFinite(val)) return val;
    let str = s(val);
    if (!str) return null;
    // Remove common currency symbols and spaces
    str = str.replace(/,/g, "");
    // Extract first valid number pattern including optional sign and decimals
    const m = str.match(/-?\d+(\.\d+)?/);
    if (!m) return null;
    const num = parseFloat(m[0]);
    return isNaN(num) ? null : num;
  }

  // Helper: parse Excel serial date number
  function dateFromExcelSerial(serial) {
    // Excel incorrectly treats 1900 as leap year; but for our purpose, typical conversion:
    // Excel epoch 1899-12-30
    const base = new Date(Date.UTC(1899, 11, 30));
    const ms = serial * 24 * 60 * 60 * 1000;
    const d = new Date(base.getTime() + ms);
    return d;
  }

  // Helper: format Date to YYYY-MM-DD in UTC
  function fmtYMD(dateObj) {
    const y = dateObj.getUTCFullYear();
    const m = String(dateObj.getUTCMonth() + 1).padStart(2, "0");
    const d = String(dateObj.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  // Helper: parse date from various formats to YYYY-MM-DD
  function parseDate(val) {
    if (val === null || val === undefined || val === "") return null;
    if (val instanceof Date && !isNaN(val)) {
      return fmtYMD(new Date(Date.UTC(val.getUTCFullYear(), val.getUTCMonth(), val.getUTCDate())));
    }
    if (typeof val === "number" && isFinite(val)) {
      // treat as Excel serial
      const d = dateFromExcelSerial(val);
      if (!isNaN(d)) return fmtYMD(d);
      return null;
    }
    let str = s(val).trim();
    if (!str) return null;

    // ISO or ISO-like
    const iso = Date.parse(str);
    if (!isNaN(iso)) {
      const d = new Date(iso);
      return fmtYMD(new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())));
    }

    // Try DD/MM/YYYY or D/M/YYYY
    let m = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
    if (m) {
      let d = parseInt(m[1], 10);
      let mo = parseInt(m[2], 10);
      let y = parseInt(m[3], 10);
      if (y < 100) y += 2000;
      // decide if it's D/M/Y or M/D/Y: prefer D/M/Y if day > 12 or typical Indian format
      if (d > 12 || (mo <= 12 && d <= 12)) {
        // Assume D/M/Y (Indian)
        const dt = new Date(Date.UTC(y, mo - 1, d));
        if (!isNaN(dt)) return fmtYMD(dt);
      } else {
        // fallback to D/M/Y
        const dt = new Date(Date.UTC(y, mo - 1, d));
        if (!isNaN(dt)) return fmtYMD(dt);
      }
    }

    // Try DD-Mon-YYYY (e.g., 01-Apr-2024)
    m = str.match(/^(\d{1,2})[\- ]([A-Za-z]{3,})[\- ](\d{4})$/);
    if (m) {
      const d = parseInt(m[1], 10);
      const monStr = m[2].toLowerCase().slice(0, 3);
      const months = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"];
      const mo = months.indexOf(monStr);
      const y = parseInt(m[3], 10);
      if (mo >= 0) {
        const dt = new Date(Date.UTC(y, mo, d));
        if (!isNaN(dt)) return fmtYMD(dt);
      }
    }

    // Could not parse
    return null;
  }

  // Helper: find IFSC code in string
  function findIFSC(str) {
    const m = s(str).match(/\b([A-Z]{4}0[A-Z0-9]{6})\b/i);
    return m ? m[1].toUpperCase() : null;
  }

  // Helper: extract city from branch string like "SURAT - GHOD DOD ROAD"
  function extractCityFromBranch(branchStr) {
    const txt = normSpace(branchStr);
    const parts = txt.split("-");
    if (parts.length >= 1) {
      const city = normSpace(parts[0]);
      if (city && city.length <= 40) return city || null;
    }
    return null;
  }

  // Helper: parse key-value style text blob like "Account No : 123", possibly multiline
  function extractDetailsFromTextBlob(text) {
    const out = {};
    const t = s(text);
    if (!t) return out;

    // Find IFSC
    const ifsc = findIFSC(t);
    if (ifsc) out.ifsc = ifsc;

    // Account No variants
    let m;
    m = t.match(/Account\s*(?:No\.?|Number|#)\s*[:\-]?\s*([A-Z0-9\- ]{6,30})/i);
    if (m) out.account_no = normSpace(m[1]).replace(/\s+/g, "");
    // Customer/Account Holder Name
    m = t.match(/(?:Account\s*Holder\s*Name|A\/c\s*Name|Customer\s*Name|Account\s*Name)\s*[:\-]?\s*([^\n\r:]+)$/im);
    if (m) out.account_holder_name = normSpace(m[1]);

    // Bank Name
    m = t.match(/Bank\s*Name\s*[:\-]?\s*([^\n\r:]+)$/im);
    if (m) out.bank_name = normSpace(m[1]);

    // Branch Name
    m = t.match(/Branch\s*(?:Name)?\s*[:\-]?\s*([^\n\r:]+)$/im);
    if (m) {
      out.branch_name = normSpace(m[1]);
      const city = extractCityFromBranch(out.branch_name);
      if (city) out.city = city;
    }

    // MICR / Branch Code
    m = t.match(/MICR\s*Code\s*[:\-]?\s*([0-9]{6,9})/i);
    if (m) out.branch_code = normSpace(m[1]);
    m = t.match(/Branch\s*Code\s*[:\-]?\s*([A-Z0-9\-]{2,})/i);
    if (m && !out.branch_code) out.branch_code = normSpace(m[1]);

    // IFSC Code explicit (for redundancy)
    m = t.match(/IFSC\s*Code\s*[:\-]?\s*([A-Z]{4}0[A-Z0-9]{6})/i);
    if (m) out.ifsc = m[1].toUpperCase();

    // Opening Balance
    m = t.match(/Opening\s*Balance\s*[:\-]?\s*([\-]?\d[\d,]*\.?\d*)/i);
    if (m) {
      const n = parseNumber(m[1]);
      if (n !== null) out.opening_balance = n;
    }

    // Branch Address / Address
    m = t.match(/Branch\s*Address\s*[:\-]?\s*([\s\S]+)/i);
    if (m) out.address = normSpace(m[1]);
    if (!out.address) {
      m = t.match(/Address\s*[:\-]?\s*([\s\S]+)/i);
      if (m) out.address = normSpace(m[1]);
    }

    // City explicit
    m = t.match(/City\s*[:\-]?\s*([^\n\r:]+)$/im);
    if (m) out.city = normSpace(m[1]);

    return out;
  }

  // Helper: merge non-nullish fields
  function mergeDetails(dst, src) {
    Object.keys(src || {}).forEach(k => {
      if (src[k] !== undefined && src[k] !== null && src[k] !== "") {
        if (!dst[k]) dst[k] = src[k];
      }
    });
    return dst;
  }

  // Identify header row and mapping
  function findHeaderAndMap(rows) {
    const headerKeywords = {
      date: ["date", "txn date", "transaction date", "trans date", "dt", "value date"],
      narration: ["narration", "description", "details", "particulars", "transaction details", "txn details"],
      debit: ["debit", "withdrawal", "withdrawal(dr)", "dr"],
      credit: ["credit", "deposit", "cr"],
      amountBoth: ["withdrawal(debit)/deposit(credit)", "withdrawal(dr)/ deposit(cr)", "withdrawal(dr)/deposit(cr)", "amount", "transaction amount"],
      balance: ["balance", "bal", "closing balance", "running balance"]
    };

    function classifyCellText(txt) {
      const t = s(txt).toLowerCase().replace(/\s+/g, " ").trim();
      return t;
    }

    const result = { headerIndex: -1, map: {} };

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i] || {};
      const keys = Object.keys(row);
      if (keys.length === 0) continue;
      let score = 0;
      const tempMap = {};

      keys.forEach(k => {
        const val = row[k];
        const t = classifyCellText(val);
        if (!t) return;

        // Date
        if (headerKeywords.date.some(w => t.includes(w))) {
          if (!tempMap.dateKey || (t === "date")) tempMap.dateKey = k;
          score++;
        }
        // Narration
        if (headerKeywords.narration.some(w => t.includes(w))) {
          if (!tempMap.narrationKey) tempMap.narrationKey = k;
          score++;
        }
        // Debit
        if (headerKeywords.debit.some(w => t.includes(w))) {
          if (!tempMap.debitKey) tempMap.debitKey = k;
          score++;
        }
        // Credit
        if (headerKeywords.credit.some(w => t.includes(w))) {
          if (!tempMap.creditKey) tempMap.creditKey = k;
          score++;
        }
        // Combined Amount
        if (headerKeywords.amountBoth.some(w => t.includes(w))) {
          if (!tempMap.amountKey) tempMap.amountKey = k;
          score += 2; // stronger signal
        }
        // Balance
        if (headerKeywords.balance.some(w => t.includes(w))) {
          if (!tempMap.balanceKey) tempMap.balanceKey = k;
          score++;
        }
      });

      // If this looks like a header row
      const hasDate = !!tempMap.dateKey;
      const hasNarr = !!tempMap.narrationKey;
      const hasAmt = !!tempMap.debitKey || !!tempMap.creditKey || !!tempMap.amountKey;
      const hasBal = !!tempMap.balanceKey;

      if ((hasDate && hasAmt) || (hasNarr && hasAmt) || (hasAmt && hasBal)) {
        result.headerIndex = i;
        result.map = tempMap;
        return result;
      }
    }

    return result;
  }

  // Parse potential "from/to" from narration
  function parseCounterparty(narration, type) {
    const text = s(narration);
    let name = null;

    // UPI/<name>/
    let m = text.match(/UPI\/([^\/]+)\//i);
    if (m) name = normSpace(m[1]);

    // IMPS/NEFT/RTGS common patterns: "NEFT-SOME NAME" or "IMPS-.../NAME/..."
    if (!name) {
      m = text.match(/NEFT[\-\/]([A-Za-z0-9 .@_-]+)/i);
      if (m) name = normSpace(m[1]);
    }
    if (!name) {
      m = text.match(/IMPS[\/\-].*?\/([A-Za-z0-9 .@_-]+)(?:\/|$)/i);
      if (m) name = normSpace(m[1]);
    }
    if (!name) {
      // Try generic: "to XYZ", "from ABC"
      m = text.match(/\bto\s+([A-Za-z0-9 .@_-]+)/i);
      if (m) name = normSpace(m[1]);
      m = text.match(/\bfrom\s+([A-Za-z0-9 .@_-]+)/i);
      if (m) name = normSpace(m[1]);
    }

    let from = null, to = null;
    if (name) {
      if (type === "deposit") from = name;
      else if (type === "withdrawal") to = name;
    }
    return { from, to };
  }

  // MAIN
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null
  };

  const transactions = [];

  if (!Array.isArray(rawData) || rawData.length === 0) {
    return { bank_details, transactions };
  }

  // 1) Bank details extraction: scan first 30 rows (and also scan globally for IFSC as fallback)
  const scanRowsCount = Math.min(30, rawData.length);
  for (let i = 0; i < scanRowsCount; i++) {
    const row = rawData[i] || {};
    Object.keys(row).forEach(k => {
      const kv = s(k);
      const vv = s(row[k]);

      // Check key and value for "label: value" pattern
      // Also parse text blobs with multiple details
      const detailsFromKey = extractDetailsFromTextBlob(kv);
      const detailsFromVal = extractDetailsFromTextBlob(vv);

      mergeDetails(bank_details, detailsFromKey);
      mergeDetails(bank_details, detailsFromVal);

      // Some rows might be like {"Label": "Value"}
      // Try to interpret if key looks like a label and value looks like a value
      const keyNorm = kv.replace(/[:\-]+$/, "").trim().toLowerCase();
      if (keyNorm) {
        if (keyNorm.includes("ifsc") || keyNorm === "ifs") {
          const found = findIFSC(vv);
          if (found) bank_details.ifsc = found;
        }
        if (includesCI(kv, "account") && includesCI(kv, "no")) {
          const acc = normSpace(vv).replace(/\s+/g, "");
          if (acc) bank_details.account_no = acc;
        }
        if (includesCI(kv, "branch") && !includesCI(kv, "address") && !includesCI(kv, "code")) {
          const bname = normSpace(vv);
          if (bname) {
            bank_details.branch_name = bank_details.branch_name || bname;
            const city = extractCityFromBranch(bname);
            if (city) bank_details.city = bank_details.city || city;
          }
        }
        if (includesCI(kv, "micr")) {
          const micr = normSpace(vv);
          if (micr) bank_details.branch_code = bank_details.branch_code || micr.replace(/\D+/g, "");
        }
        if (includesCI(kv, "bank name")) {
          const b = normSpace(vv);
          if (b) bank_details.bank_name = bank_details.bank_name || b;
        }
        if (includesCI(kv, "address")) {
          const addr = normSpace(vv);
          if (addr) bank_details.address = bank_details.address || addr;
        }
        if (includesCI(kv, "opening") && includesCI(kv, "balance")) {
          const ob = parseNumber(vv);
          if (ob !== null) bank_details.opening_balance = ob;
        }
        if ((includesCI(kv, "customer") && includesCI(kv, "name")) || includesCI(kv, "account holder name") || includesCI(kv, "a/c name")) {
          const nm = normSpace(vv);
          if (nm) bank_details.account_holder_name = bank_details.account_holder_name || nm;
        }
      }
    });
  }

  // If IFSC not yet found, scan entire data values for IFSC
  if (!bank_details.ifsc) {
    for (let i = 0; i < rawData.length && !bank_details.ifsc; i++) {
      const row = rawData[i] || {};
      Object.keys(row).some(k => {
        const val = row[k];
        const found = findIFSC(k) || findIFSC(val);
        if (found) {
          bank_details.ifsc = found;
          return true;
        }
        return false;
      });
    }
  }

  // 2) Find header row and map keys
  const { headerIndex, map } = findHeaderAndMap(rawData);

  if (headerIndex === -1) {
    // No transactions header, return only bank details
    return { bank_details, transactions };
  }

  // 3) Process transactions after header
  let voucher = 1;
  for (let i = headerIndex + 1; i < rawData.length; i++) {
    const row = rawData[i] || {};
    // Extract fields
    const dateRaw = map.dateKey ? row[map.dateKey] : null;
    const narrRaw = map.narrationKey ? row[map.narrationKey] : null;
    const debitRaw = map.debitKey ? row[map.debitKey] : null;
    const creditRaw = map.creditKey ? row[map.creditKey] : null;
    const amountRaw = map.amountKey ? row[map.amountKey] : null;
    const balanceRaw = map.balanceKey ? row[map.balanceKey] : null;

    // Skip clearly empty rows
    const valuesStr = Object.values(row).map(s).join(" ").trim();
    if (!valuesStr) continue;

    let dateStr = parseDate(dateRaw);
    // If date missing/invalid and there's also a "value date" column mislabeled as date, try parse any value like 'value date'
    if (!dateStr) {
      // Try to find any date-looking value in the row keys not ideal, but fallback
      let guessed = null;
      Object.keys(row).forEach(k => {
        const maybe = parseDate(row[k]);
        if (!guessed && maybe) guessed = maybe;
      });
      dateStr = guessed;
    }

    // If no parsable date, likely not a transaction
    if (!dateStr) continue;

    const narration = normSpace(narrRaw || "");

    // Amount determination
    let amount = null;
    let type = null; // "withdrawal" or "deposit"

    // Combined amount column with Dr/Cr
    if (amountRaw !== null && amountRaw !== undefined && s(amountRaw)) {
      const amtStr = s(amountRaw);
      const num = parseNumber(amtStr);
      if (num !== null) {
        amount = Math.abs(num);
        if (/dr\)?/i.test(amtStr) || includesCI(amtStr, "debit") || includesCI(amtStr, "withdrawal")) {
          type = "withdrawal";
        } else if (/cr\)?/i.test(amtStr) || includesCI(amtStr, "credit") || includesCI(amtStr, "deposit")) {
          type = "deposit";
        } else if (num < 0) {
          type = "withdrawal";
          amount = Math.abs(num);
        }
      }
    }

    // Separate debit/credit columns
    const dnum = parseNumber(debitRaw);
    const cnum = parseNumber(creditRaw);

    if (dnum !== null && dnum > 0) {
      // prioritize debit if both exist
      amount = dnum;
      type = "withdrawal";
    } else if (cnum !== null && cnum > 0) {
      if (amount === null) {
        amount = cnum;
        type = "deposit";
      }
    }

    // If still no amount or type, skip row
    if (amount === null || !type) continue;

    // Balance
    let balance = null;
    const balNum = parseNumber(balanceRaw);
    if (balNum !== null) balance = balNum;

    // From/To
    const cp = parseCounterparty(narration, type);

    const tx = {
      date: dateStr,
      voucher_number: voucher++,
      amount: amount,
      desc: narration,
      from: cp.from || null,
      to: cp.to || null,
      type: type,
      balance: balance !== null ? balance : null
    };

    transactions.push(tx);
  }

  // 4) Ensure opening_balance number
  if (typeof bank_details.opening_balance !== "number" || !isFinite(bank_details.opening_balance)) {
    bank_details.opening_balance = 0;
  }

  // Ensure mandatory IFSC is uppercase string if found, else null (best effort)
  if (bank_details.ifsc) bank_details.ifsc = bank_details.ifsc.toUpperCase();

  return { bank_details, transactions };
}

module.exports = processBankStatement;
/**
 * Generated by Gemini AI - Attempt 1
 * Processes bank statement data from Excel
 * @param {Array} rawData - Array of objects from bank statement Excel
 * @returns {Object} Processed bank statement data
 */
function processBankStatement(rawData) {
  const bank_details = {
    bank_name: null,
    opening_balance: 0,
    ifsc: null,
    address: null,
    city: null,
    account_no: null,
    account_holder_name: null,
    branch_name: null,
    branch_code: null,
  }
  const transactions = []
  let headerRowIndex = -1
  let keyMap = {}

  // Helper function to parse dates in various formats
  function parseDate(dateString) {
    if (!dateString) return null

    const excelSerialDateRegex = /^\d+$/

    if (excelSerialDateRegex.test(dateString)) {
      const excelSerialDate = parseInt(dateString, 10)
      const epoch = new Date(Date.UTC(1899, 11, 30)) // Start date for Excel serial numbers
      const javascriptDate = new Date(epoch.getTime() + excelSerialDate * 24 * 60 * 60 * 1000)
      const year = javascriptDate.getFullYear()
      const month = String(javascriptDate.getMonth() + 1).padStart(2, '0')
      const day = String(javascriptDate.getDate()).padStart(2, '0')
      return `${year}-${month}-${day}`
    }

    const formats = [
      { regex: /(\d{2})\/(\d{2})\/(\d{4})/, format: '$3-$2-$1' }, // DD/MM/YYYY
      {
        regex: /(\d{2})-(\w+)-(\d{4})/,
        format: (match) => {
          const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
          const monthIndex = monthNames.findIndex((m) => m === match[2].toLowerCase().substring(0, 3))
          if (monthIndex === -1) return null
          const month = String(monthIndex + 1).padStart(2, '0')
          return `${match[3]}-${month}-${match[1]}`
        },
      }, // DD-Mon-YYYY
      {
        regex: /(\d{2})\/(\d{2})\/(\d{2})/,
        format: (match) => {
          const year = `20${match[3]}`
          return `${year}-${match[2]}-${match[1]}`
        },
      }, // DD/MM/YY
      { regex: /(\d{4})-(\d{2})-(\d{2})/, format: '$1-$2-$3' }, //YYYY-MM-DD
      { regex: /(\d{2})-(\d{2})-(\d{4})/, format: '$3-$2-$1' }, //MM-DD-YYYY
      {
        regex: /(\d{2})-(\w+)-(\d{2})/,
        format: (match) => {
          const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
          const monthIndex = monthNames.findIndex((m) => m === match[2].toLowerCase().substring(0, 3))
          if (monthIndex === -1) return null
          const month = String(monthIndex + 1).padStart(2, '0')
          const year = `20${match[3]}`
          return `${year}-${month}-${match[1]}`
        },
      }, // DD-Mon-YY
      { regex: /(\d{2})\/(\d{2})-(\d{4})/, format: '$3-$1-$2' }, // MM/DD/YYYY
      { regex: /(\d{2})\.(\d{2})\.(\d{4})/, format: '$3-$2-$1' }, // DD.MM.YYYY
      { regex: /(\d{4})\/(\d{2})\/(\d{2})/, format: '$1-$2-$3' }, // YYYY/MM/DD
      {
        regex: /(\d{1})\/(\d{1})\/(\d{4})/,
        format: (match) => {
          const day = String(match[1]).padStart(2, '0')
          const month = String(match[2]).padStart(2, '0')
          return `${match[3]}-${month}-${day}`
        },
      }, // M/D/YYYY
      {
        regex: /(\d{1})\/(\d{2})\/(\d{4})/,
        format: (match) => {
          const day = String(match[1]).padStart(2, '0')
          return `${match[3]}-${match[2]}-${day}`
        },
      }, // D/MM/YYYY
      {
        regex: /(\d{2})\/(\d{1})\/(\d{4})/,
        format: (match) => {
          const month = String(match[2]).padStart(2, '0')
          return `${match[3]}-${month}-${match[1]}`
        },
      }, // MM/D/YYYY
    ]

    for (const format of formats) {
      const match = dateString.match(format.regex)
      if (match) {
        if (typeof format.format === 'string') {
          return dateString.replace(format.regex, format.format)
        } else if (typeof format.format === 'function') {
          return format.format(match)
        }
      }
    }
    return null
  }

  // Bank Details Extraction
  for (let i = 0; i < Math.min(20, rawData.length); i++) {
    const row = rawData[i]
    if (!row) continue

    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = row[key]

        if (typeof value === 'string') {
          const cleanedValue = value.trim().toLowerCase()
          // New logic: Extract account holder name and account number from a combined string
          const combinedMatch = value.match(/Transactions List\s*-\s*(.+?)\s*-\s*(\d{9,})/i)
          if (combinedMatch) {
            bank_details.account_holder_name = combinedMatch[1].trim()
            bank_details.account_no = combinedMatch[2].trim()
          }
          if (cleanedValue.includes('bank name')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.bank_name = row[adjacentKey] || null
          } else if (cleanedValue.includes('account holder name') || cleanedValue.includes('account name')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.account_holder_name = row[adjacentKey] || null
          } else if (cleanedValue.includes('account no') || cleanedValue.includes('account number')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.account_no = row[adjacentKey] || null
          } else if (cleanedValue.includes('ifsc') || cleanedValue.includes('ifs')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.ifsc = row[adjacentKey] || null
          } else if (cleanedValue.includes('branch name')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.branch_name = row[adjacentKey] || null
          } else if (cleanedValue.includes('branch code')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.branch_code = row[adjacentKey] || null
          } else if (cleanedValue.includes('address')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            bank_details.address = row[adjacentKey] || null
          } else if (cleanedValue.includes('opening balance')) {
            const adjacentKey = Object.keys(row).find((k) => k !== key)
            const openingBalanceValue = row[adjacentKey]
            if (typeof openingBalanceValue === 'number') {
              bank_details.opening_balance = openingBalanceValue
            } else if (typeof openingBalanceValue === 'string') {
              const parsedValue = parseFloat(openingBalanceValue.replace(/[^0-9.-]+/g, ''))
              if (!isNaN(parsedValue)) {
                bank_details.opening_balance = parsedValue
              }
            }
          }
        }
      }
    }
  }

  // Set default opening balance if not found.
  if (bank_details.opening_balance === null || bank_details.opening_balance === undefined) {
    bank_details.opening_balance = 0
  }

  // Header Row Identification & Key Mapping
  for (let i = 0; i < rawData.length; i++) {
    const row = rawData[i]
    if (!row) continue

    let dateKey = null
    let narrationKey = null
    let debitKey = null
    let creditKey = null
    let balanceKey = null

    for (const key in row) {
      if (row.hasOwnProperty(key)) {
        const value = row[key]

        if (typeof value === 'string') {
          const cleanedValue = value.trim().toLowerCase()
          if (cleanedValue.includes('date') || cleanedValue.includes('txn date')) {
            dateKey = key
          }
          if (
            cleanedValue.includes('narration') ||
            cleanedValue.includes('description') ||
            cleanedValue.includes('details') ||
            cleanedValue.includes('remarks') ||
            cleanedValue.includes('transaction details')
          ) {
            narrationKey = key
          }
          if (cleanedValue.includes('withdrawal') || cleanedValue.includes('debit')) {
            debitKey = key
          }
          if (cleanedValue.includes('deposit') || cleanedValue.includes('credit')) {
            creditKey = key
          }
          if (cleanedValue.includes('balance') || cleanedValue.includes('closing balance')) {
            balanceKey = key
          }
        }
      }
    }

    if (dateKey && narrationKey && (debitKey || creditKey) && balanceKey) {
      headerRowIndex = i
      keyMap = {
        dateKey: dateKey,
        narrationKey: narrationKey,
        debitKey: debitKey,
        creditKey: creditKey,
        balanceKey: balanceKey,
      }
      break
    }
  }

  // Transaction Processing
  let voucher_number = 1
  for (let i = headerRowIndex + 1; i < rawData.length; i++) {
    const row = rawData[i]
    if (!row) continue

    const dateString = row[keyMap.dateKey]
    const desc = row[keyMap.narrationKey]?.trim() || null
    const debitValue = row[keyMap.debitKey]
    const creditValue = row[keyMap.creditKey]
    const balanceValue = row[keyMap.balanceKey]

    const date = parseDate(dateString)

    let amount = null
    let type = null

    if (debitValue !== null && debitValue !== undefined && debitValue !== '') {
      const parsedDebit = typeof debitValue === 'number' ? debitValue : parseFloat(String(debitValue).replace(/[^0-9.-]+/g, ''))
      if (!isNaN(parsedDebit) && parsedDebit > 0) {
        amount = parsedDebit
        type = 'withdrawal'
      }
    }

    if (creditValue !== null && creditValue !== undefined && creditValue !== '') {
      const parsedCredit = typeof creditValue === 'number' ? creditValue : parseFloat(String(creditValue).replace(/[^0-9.-]+/g, ''))
      if (!isNaN(parsedCredit) && parsedCredit > 0) {
        amount = parsedCredit
        type = 'deposit'
      }
    }

    const parsedBalance = typeof balanceValue === 'number' ? balanceValue : parseFloat(String(balanceValue).replace(/[^0-9.-]+/g, ''))

    if (date && desc && amount !== null && type && !isNaN(parsedBalance)) {
      const transaction = {
        date: date,
        voucher_number: voucher_number,
        amount: amount,
        desc: desc,
        from: null,
        to: null,
        type: type,
        balance: parsedBalance,
      }

      transactions.push(transaction)
      voucher_number++
    }
  }

  return {
    bank_details: bank_details,
    transactions: transactions,
  }
}

module.exports = processBankStatement
